// Vendor-Specific Exporter
// Generates parameter sheets for Siemens, GE, and Philips scanners

const VendorExporter = {
    /**
     * Export for Siemens IDEA
     */
    exportSiemens(sequenceData) {
        return `/* ========================================
   Siemens IDEA Sequence Parameters
   Generated by Hyperpolarized Pulse Sequence Generator
   ========================================*/

// Basic Parameters
sProtocol PARAMS_TYPE = "Hyperpolarized ${sequenceData.nucleus || 'C13'} Imaging";
sSliceArray.asSlice[0].dThickness = ${sequenceData.sliceThickness || 10};  // mm
sSliceArray.asSlice[0].dPhaseFOV = ${sequenceData.fov || 240};  // mm
sSliceArray.asSlice[0].dReadoutFOV = ${sequenceData.fov || 240};  // mm

// Sequence Timing
alTR[0] = ${sequenceData.tr || 100000};  // μs
alTE[0] = ${sequenceData.te || 20000};  // μs

// Matrix
sKSpace.lBaseResolution = ${sequenceData.matrixSize || 64};
sKSpace.lPhaseEncodingLines = ${sequenceData.matrixSize || 64};

// RF Pulses - Variable Flip Angle Schedule
${sequenceData.flipAngles ? this.generateSiemensVFA(sequenceData.flipAngles) : '// VFA not configured'}

// Gradient Parameters
sGRADSPEC.asGPAData[0].flAmplitude = ${sequenceData.maxGrad || 40};  // mT/m
sGRADSPEC.asGPAData[0].flRiseTime = ${sequenceData.slewRate ? (sequenceData.maxGrad / sequenceData.slewRate * 1000) : 0.27};  // ms

// Transmit Frequency
sTXSPEC.asNucleusInfo[0].lFrequency = ${this.calculateLarmorFrequency(sequenceData.nucleus, sequenceData.b0Field || 3.0)};  // Hz
sTXSPEC.asNucleusInfo[0].tNucleus = "${sequenceData.nucleus || '13C'}";

// Image Reconstruction
sKSpace.uc2DInterpolation = 1;  // Enable
sKSpace.ucDimension = 2;  // 2D imaging

/* ========================================
   Implementation Notes:
   
   1. This sequence requires custom sequence development
   2. VFA schedule must be implemented in sequence code
   3. Chemical shift encoding may require spectral-spatial pulses
   4. Recommended to use WIP packages for hyperpolarized imaging
   
   Contact Siemens Healthineers for IDEA sequence development
   ========================================*/
`;
    },

    /**
     * Generate Siemens VFA array
     */
    generateSiemensVFA(flipAngles) {
        let code = `// Variable Flip Angle Array\ndouble aFlipAngleArray[${flipAngles.length}] = {\n`;

        for (let i = 0; i < flipAngles.length; i++) {
            code += `    ${flipAngles[i].toFixed(2)}`;
            if (i < flipAngles.length - 1) code += ',';
            code += `  // Frame ${i + 1}\n`;
        }

        code += '};';
        return code;
    },

    /**
     * Export for GE EPIC
     */
    exportGE(sequenceData) {
        return `/* ========================================
   GE EPIC Sequence Parameters
   Generated by Hyperpolarized Pulse Sequence Generator
   ========================================*/

/* CVs (Control Variables) */
#include "epicconf.h"
#include "psd.h"

/* Sequence Identification */
@cv char psdname[33] = "hyperpolarized_${sequenceData.type || 'vfa'}";

/* Imaging Parameters */
@cv int opfov = ${sequenceData.fov || 240};      /* FOV (mm) */
@cv int opslthick = ${sequenceData.sliceThickness || 10};  /* Slice thickness (mm) */
@cv int optr = ${(sequenceData.tr || 100) * 1000};  /* TR (μs) */
@cv int opte = ${(sequenceData.te || 20) * 1000};   /* TE (μs) */

/* Matrix Size */
@cv int opxres = ${sequenceData.matrixSize || 64};  /* X resolution */
@cv int opyres = ${sequenceData.matrixSize || 64};  /* Y resolution */

/* Flip Angle Schedule - VFA */
@cv int opnframes = ${sequenceData.numFrames || 20};  /* Number of dynamic frames */

${sequenceData.flipAngles ? this.generateGEVFA(sequenceData.flipAngles) : '/* VFA table not configured */'}

/* Gradient Specifications */
@cv float gmax = ${sequenceData.maxGrad || 40};  /* Max gradient (mT/m) */
@cv float slewmax = ${sequenceData.slewRate || 150};  /* Max slew rate (T/m/s) */

/* Nucleus Configuration */
@cv char nucleus[8] = "${sequenceData.nucleus || '13C'}";
@cv int opnuc = ${this.getNucleusCode(sequenceData.nucleus)};  /* Nucleus code */

/* Frequency/Transmitter */
@cv float xmitfreq = ${this.calculateLarmorFrequency(sequenceData.nucleus, sequenceData.b0Field || 3.0) / 1e6};  /* MHz */

/* Readout Configuration */
${this.getGEReadoutConfig(sequenceData.readoutType)}

/* ========================================
   EPIC Implementation Notes:
   
   1. Requires EPIC programming environment
   2. VFA implementation in @pg section
   3. Multi-nuclear setup requires special configuration
   4. Contact GE Healthcare for EPIC development tools
   
   Reference: GE EPIC Programming Guide
   ========================================*/
`;
    },

    /**
     * Generate GE VFA array
     */
    generateGEVFA(flipAngles) {
        let code = `/* Flip angle table for VFA */\n@cv float vfa_schedule[${flipAngles.length}] = {\n`;

        for (let i = 0; i < flipAngles.length; i++) {
            code += `    ${flipAngles[i].toFixed(2)}`;
            if (i < flipAngles.length - 1) code += ',';
            code += ` /* Frame ${i + 1} */\n`;
        }

        code += '};';
        return code;
    },

    /**
     * Get GE nucleus code
     */
    getNucleusCode(nucleus) {
        const codes = {
            '1H': 1,
            '13C': 6,
            '129Xe': 54,
            '3He': 2,
            '31P': 15
        };
        return codes[nucleus] || 0;
    },

    /**
     * Get GE readout configuration
     */
    getGEReadoutConfig(readoutType) {
        switch (readoutType) {
            case 'spiral':
                return `/* Spiral readout */
@cv int opnshots = 8;  /* Number of spiral interleaves */
@cv int oprbw = 125;   /* Receiver bandwidth (kHz) */`;
            case 'epi':
                return `/* EPI readout */
@cv int opepi = 1;     /* EPI enable */
@cv int opnshots = 1;  /* Single-shot */`;
            default:
                return `/* Cartesian readout */`;
        }
    },

    /**
     * Export for Philips
     */
    exportPhilips(sequenceData) {
        return `# ========================================
# Philips Sequence Parameter Sheet
# Generated by Hyperpolarized Pulse Sequence Generator
# ========================================

[PROTOCOL]
Protocol_name = Hyperpolarized_${sequenceData.type || 'VFA'}
Technique = ${this.getPhilipsTechnique(sequenceData.readoutType)}

[GEOMETRY]
FOV_AP = ${sequenceData.fov || 240}  # mm
FOV_FH = ${sequenceData.fov || 240}  # mm
FOV_RL = ${sequenceData.fov || 240}  # mm
Slice_thickness = ${sequenceData.sliceThickness || 10}  # mm
Number_of_slices = ${sequenceData.numSlices || 1}

[CONTRAST]
TR = ${sequenceData.tr || 100}  # ms
TE = ${sequenceData.te || 20}   # ms
Flip_angle = Variable  # See VFA schedule below

[VFA_SCHEDULE]
# Frame number, Flip angle (degrees)
${sequenceData.flipAngles ? this.generatePhilipsVFA(sequenceData.flipAngles) : '# VFA not configured'}

[RESOLUTION]
Scan_resolution_1 = ${sequenceData.matrixSize || 64}
Scan_resolution_2 = ${sequenceData.matrixSize || 64}
Reconstruction_matrix = ${(sequenceData.matrixSize || 64) * 2}

[NUCLEUS]
Nucleus = ${sequenceData.nucleus || '13C'}
Frequency = ${this.calculateLarmorFrequency(sequenceData.nucleus, sequenceData.b0Field || 3.0) / 1e6} MHz
B0_field = ${sequenceData.b0Field || 3.0} T

[DYNAMICS]
Number_of_dynamics = ${sequenceData.numFrames || 20}
Dynamic_scan = Yes
Temporal_resolution = ${sequenceData.temporalResolution || 2.0} s

[ADVANCED]
Max_gradient_amplitude = ${sequenceData.maxGrad || 40} mT/m
Max_slew_rate = ${sequenceData.slewRate || 150} T/m/s
Partial_Fourier = ${sequenceData.partialFourier || 1.0}

# ========================================
# Implementation Notes:
# 
# 1. Philips requires custom research protocol
# 2. Multi-nuclear imaging requires special license
# 3. VFA implementation via dynamic loops
# 4. Contact Philips Healthcare for development access
# 
# Reference: Philips Research Interface documentation
# ========================================
`;
    },

    /**
     * Generate Philips VFA table
     */
    generatePhilipsVFA(flipAngles) {
        let table = '';
        for (let i = 0; i < flipAngles.length; i++) {
            table += `${i + 1}, ${flipAngles[i].toFixed(2)}\n`;
        }
        return table;
    },

    /**
     * Get Philips technique name
     */
    getPhilipsTechnique(readoutType) {
        const techniques = {
            'spiral': 'Spiral',
            'epi': 'EPI',
            'cartesian': 'FFE',
            'radial': 'Radial'
        };
        return techniques[readoutType] || 'Custom';
    },

    /**
     * Calculate Larmor frequency
     */
    calculateLarmorFrequency(nucleus, b0Field) {
        const gammaValues = {
            '1H': 42.58,
            '13C': 10.7084,
            '129Xe': 11.8604,
            '3He': 32.434,
            '31P': 17.235
        };

        const gamma = gammaValues[nucleus] || 42.58;
        return gamma * b0Field * 1e6; // Hz
    }
};

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = VendorExporter;
}
