// PyPulseq Exporter
// Generates PyPulseq-compatible Python code for sequences

const PyPulseqExporter = {
    /**
     * Export complete VFA sequence to PyPulseq
     */
    exportVFASequence(vfaSchedule, readoutType, nucleiProps, options = {}) {
        const code = `#!/usr/bin/env python3
"""
Hyperpolarized ${nucleiProps.name} Imaging Sequence
Variable Flip Angle (VFA) Strategy
Generated by Hyperpolarized Pulse Sequence Generator - Sunnybrook Research Institute
"""

import numpy as np
import matplotlib.pyplot as plt
from pypulseq import Sequence, make_sinc_pulse, make_trapezoid, make_adc, make_delay, Opts

# ===== Sequence Parameters =====
system = Opts(
    max_grad=40,  # mT/m
    grad_unit='mT/m',
    max_slew=150,  # T/m/s
    slew_unit='T/m/s',
    rf_ringdown_time=20e-6,
    rf_dead_time=100e-6,
    adc_dead_time=10e-6
)

# Imaging parameters
fov = ${options.fov || 0.24}  # m
slice_thickness = ${options.sliceThickness || 0.01}  # m
num_frames = ${vfaSchedule.numFrames}
tr = ${vfaSchedule.parameters.tr / 1000}  # s

# Nucleus properties
gamma = ${Math.abs(nucleiProps.gamma) * 2 * Math.PI}  # rad/s/T
t1 = ${nucleiProps.t1}  # s

# VFA schedule
flip_angles = np.array([${vfaSchedule.flipAngles.map(a => a.toFixed(2)).join(', ')}])  # degrees

# ===== Create Sequence =====
seq = Sequence(system)

# Create readout module (${readoutType})
${this.generateReadoutModule(readoutType, options)}

# ===== Build Dynamic VFA Sequence =====
for frame in range(num_frames):
    flip_rad = np.deg2rad(flip_angles[frame])
    
    # RF pulse with variable flip angle
    rf, gz, gz_reph = make_sinc_pulse(
        flip_angle=flip_rad,
        system=system,
        duration=2e-3,  # 2 ms
        slice_thickness=slice_thickness,
        apodization=0.5,
        time_bw_product=4,
        return_gz=True
    )
    
    # Add to sequence
    seq.add_block(rf, gz)
    seq.add_block(gz_reph)
    
    # Add readout
    ${this.addReadoutBlock(readoutType)}
    
    # TR delay
    seq.add_block(make_delay(tr))

# ===== Sequence Validation =====
ok, error_report = seq.check_timing()
if ok:
    print("Sequence timing check passed")
else:
    print("Sequence timing check failed:")
    print(error_report)

# ===== Export Sequence =====
seq.write('hyperpolarized_vfa_${readoutType}.seq')
print(f"Sequence exported: hyperpolarized_vfa_${readoutType}.seq")

# ===== Plot Sequence =====
seq.plot(time_range=[0, tr*3])  # Plot first 3 frames

# Calculate and plot predicted signal evolution
predicted_signals = np.array([${vfaSchedule.signals.map(s => s.toFixed(6)).join(', ')}])
time_points = np.arange(num_frames) * tr

plt.figure(figsize=(10, 6))
plt.plot(time_points, predicted_signals, 'o-', linewidth=2, label='Predicted Signal')
plt.xlabel('Time (s)')
plt.ylabel('Normalized Signal')
plt.title('${nucleiProps.name} Signal Evolution with VFA')
plt.grid(True, alpha=0.3)
plt.legend()
plt.tight_layout()
plt.savefig('signal_evolution.png', dpi=300)
plt.show()

print(f"Total SNR efficiency: {${vfaSchedule.efficiency.toFixed(2)}}%")
`;

        return code;
    },

    /**
     * Generate readout module code based on type
     */
    generateReadoutModule(readoutType, options) {
        switch (readoutType) {
            case 'spiral':
                return `# Spiral readout parameters
num_interleaves = 8
readout_duration = 20e-3  # 20 ms

# Generate spiral trajectory (simplified - use vds or other tool for production)
def make_spiral_gradients():
    # Placeholder for spiral gradient generation
    # Use external spiral design tool or implement Archimedean spiral
    pass`;

            case 'epi':
                return `# EPI readout parameters
matrix_size = 64
echo_spacing = 0.5e-3  # ms
num_echoes = matrix_size

# EPI readout gradient
gx_readout = make_trapezoid(channel='x', amplitude=40, flat_time=echo_spacing*matrix_size, system=system)`;

            case 'cartesian':
                return `# Cartesian readout parameters
matrix_size = 64
readout_time = 4e-3  # ms

# Frequency encoding gradient
gx = make_trapezoid(channel='x', flat_area=matrix_size/fov, flat_time=readout_time, system=system)`;

            default:
                return `# Generic readout module`;
        }
    },

    /**
     * Add readout block code
     */
    addReadoutBlock(readoutType) {
        switch (readoutType) {
            case 'spiral':
                return `# seq.add_block(gx_spiral, gy_spiral, adc)`;
            case 'epi':
                return `# seq.add_block(gx_readout, adc)  # Add full EPI train`;
            default:
                return `# seq.add_block(gx, adc)`;
        }
    },

    /**
     * Export spiral sequence specifically
     */
    exportSpiralSequence(spiralTrajectory, options = {}) {
        const code = `#!/usr/bin/env python3
"""
Spiral Trajectory for Hyperpolarized Imaging
Generated by Hyperpolarized Pulse Sequence Generator
"""

import numpy as np
from pypulseq import Sequence, make_arbitrary_grad, make_adc, Opts

system = Opts(max_grad=40, grad_unit='mT/m', max_slew=150, slew_unit='T/m/s')

# Spiral parameters
readout_duration = ${spiralTrajectory.readoutDuration / 1000}  # s
num_interleaves = ${spiralTrajectory.interleaves}
kmax = ${spiralTrajectory.kmax}  # cm^-1

# Gradient waveforms (mT/m)
gx_wave = np.array([${spiralTrajectory.gx.slice(0, 50).map(g => g.toFixed(3)).join(', ')}])  # ... ${spiralTrajectory.gx.length} points total
gy_wave = np.array([${spiralTrajectory.gy.slice(0, 50).map(g => g.toFixed(3)).join(', ')}])

# Time vector
time_wave = np.array([${spiralTrajectory.time.slice(0, 50).map(t => (t * 1000).toFixed(6)).join(', ')}])  # ms

# Create arbitrary gradients
gx = make_arbitrary_grad(channel='x', waveform=gx_wave, system=system)
gy = make_arbitrary_grad(channel='y', waveform=gy_wave, system=system)

# ADC
num_samples = len(gx_wave)
adc = make_adc(num_samples=num_samples, duration=readout_duration, system=system)

# Create sequence for all interleaves
seq = Sequence(system)

for interleave in range(num_interleaves):
    angle = 2 * np.pi * interleave / num_interleaves
    cos_a, sin_a = np.cos(angle), np.sin(angle)
    
    # Rotate gradients
    gx_rot_wave = gx_wave * cos_a - gy_wave * sin_a
    gy_rot_wave = gx_wave * sin_a + gy_wave * cos_a
    
    gx_rot = make_arbitrary_grad(channel='x', waveform=gx_rot_wave, system=system)
    gy_rot = make_arbitrary_grad(channel='y', waveform=gy_rot_wave, system=system)
    
    seq.add_block(gx_rot, gy_rot, adc)

seq.write('spiral_hyperpolarized.seq')
print("Spiral sequence exported")
`;

        return code;
    },

    /**
     * Export full sequence with all components
     */
    exportFullSequence(sequenceData) {
        return `#!/usr/bin/env python3
"""
Complete Hyperpolarized Imaging Sequence
Generated by Hyperpolarized Pulse Sequence Generator - Sunnybrook Research Institute

Sequence Type: ${sequenceData.type}
Nucleus: ${sequenceData.nucleus}
Generated: ${new Date().toISOString()}
"""

import numpy as np
from pypulseq import Sequence, Opts
from pypulseq import make_sinc_pulse, make_trapezoid, make_adc, make_delay

# System limits
system = Opts(
    max_grad=40,  # mT/m
    grad_unit='mT/m',
    max_slew=150,  # T/m/s
    slew_unit='T/m/s',
    rf_ringdown_time=20e-6,
    rf_dead_time=100e-6,
    adc_dead_time=10e-6,
    grad_raster_time=10e-6,
    rf_raster_time=1e-6
)

# Sequence parameters
${JSON.stringify(sequenceData.parameters, null, 4).split('\n').map(line => '# ' + line).join('\n')}

# Build sequence
seq = Sequence(system)

# ... Add sequence blocks ...

# Export
seq.write('${sequenceData.filename || 'hyperpolarized_sequence.seq'}')
print("Sequence exported successfully")
`;
    }
};

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = PyPulseqExporter;
}
