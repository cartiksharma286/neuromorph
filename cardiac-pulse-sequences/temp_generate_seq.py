#!/usr/bin/env python3
"""
Cardiac MRI Pulse Sequence - Generated by Cardiac Parallel Imaging Generator
Configuration: "SENSE"
Acceleration Factor: R = 2x
"""

import pypulseq as pp
import numpy as np

# Create sequence object
seq = pp.Sequence()

# System limits
system = pp.Opts(
    max_grad=32,  # mT/m
    grad_unit='mT/m',
    max_slew=130,  # T/m/s
    slew_unit='T/m/s',
    rf_ringdown_time=20e-6,
    rf_dead_time=100e-6,
    adc_dead_time=10e-6
)

# Imaging parameters
fov = 400e-3  # m
Nx, Ny = 256, 256
slice_thickness = 8e-3  # m
TE = 1.5e-3  # s
TR = 3e-3  # s

# Parallel imaging
acceleration_factor = 2
num_acs_lines = 24

# Calculate k-space sampling
delta_k = 1 / fov
k_width = Nx * delta_k
readout_time = 6.4e-3  # s

# Create 90-degree slice selection pulse
rf, gz, _ = pp.make_sinc_pulse(
    flip_angle=90 * np.pi / 180,
    duration=2e-3,
    slice_thickness=slice_thickness,
    apodization=0.5,
    time_bw_product=4,
    system=system,
    return_gz=True
)

# Create readout gradient
gx = pp.make_trapezoid(
    channel='x',
    flat_area=k_width,
    flat_time=readout_time,
    system=system
)

# Create ADC event
adc = pp.make_adc(
    num_samples=Nx,
    duration=readout_time,
    delay=gx.rise_time,
    system=system
)

# Phase encoding (undersampled for parallel imaging)
phase_areas = np.arange(Ny) - Ny / 2
phase_areas = phase_areas * delta_k

# Generate undersampled k-space pattern
if "sense" == "grappa":
    # GRAPPA: uniform undersampling + ACS region
    sampled_lines = []
    for pe in range(Ny):
        if pe % int(acceleration_factor) == 0:
            sampled_lines.append(pe)
        elif abs(pe - Ny//2) < num_acs_lines // 2:
            sampled_lines.append(pe)  # ACS region
else:
    # SENSE: uniform undersampling
    sampled_lines = [pe for pe in range(Ny) if pe % int(acceleration_factor) == 0]

print(f"Acquiring {len(sampled_lines)} / {Ny} phase encode lines")
print(f"Effective R = {Ny / len(sampled_lines):.2f}x")

# Build sequence
for pe_idx in sampled_lines:
    # RF excitation
    seq.add_block(rf, gz)
    
    # Phase encoding
    gy = pp.make_trapezoid(
        channel='y',
        area=phase_areas[pe_idx],
        duration=2e-3,
        system=system
    )
    
    # Prephasing
    gx_pre = pp.make_trapezoid(
        channel='x',
        area=-gx.area / 2,
        duration=1e-3,
        system=system
    )
    
    seq.add_block(gx_pre, gy)
    
    # Readout
    seq.add_block(gx, adc)
    
    # Spoiling
    gx_spoil = pp.make_trapezoid(
        channel='x',
        area=2 * k_width,
        duration=1e-3,
        system=system
    )
    
    seq.add_block(gx_spoil)

# Check sequence timing
ok, error_report = seq.check_timing()
if ok:
    print("Sequence timing check passed!")
else:
    print("Timing errors detected:")
    print(error_report)

# Output statistics
print(f"\nSequence Statistics:")
print(f"Total duration: {seq.duration()[0]:.2f} s")
print(f"Number of blocks: {len(seq.block_events)}")

# Write sequence
seq.write("cardiac_sequence.seq")
print("\nSequence written to: cardiac_sequence.seq")
