// Export Functionality for PyPulseq and Other Formats

const ExportModule = {
    /**
     * Initialize export buttons
     */
    init() {
        const exportPyPulseq = document.getElementById('export-pypulseq');
        const exportVendor = document.getElementById('export-vendor');
        const exportProtocol = document.getElementById('export-protocol');

        if (exportPyPulseq) {
            exportPyPulseq.addEventListener('click', () => this.exportPyPulseq());
        }

        if (document.getElementById('write-seq-file')) {
            document.getElementById('write-seq-file').addEventListener('click', () => this.writeSeqFile());
        }

        if (exportVendor) {
            exportVendor.addEventListener('click', () => this.exportVendor());
        }

        if (exportProtocol) {
            exportProtocol.addEventListener('click', () => this.exportProtocol());
        }

        console.log('Export module initialized');
    },

    /**
     * Export to PyPulseq format
     */
    exportPyPulseq() {
        const config = this.gatherConfiguration();
        const pypulseqCode = this.generatePyPulseqCode(config);

        Utils.downloadFile(pypulseqCode, 'cardiac_sequence.py', 'text/plain');

        if (window.LLMInterface) {
            LLMInterface.addMessage('assistant', '✓ PyPulseq code exported successfully!');
        }
    },

    /**
     * Write .seq file on server (Auto-confirm)
     */
    async writeSeqFile() {
        const config = this.gatherConfiguration();
        const pypulseqCode = this.generatePyPulseqCode(config);

        if (window.LLMInterface) {
            LLMInterface.addMessage('assistant', '⏳ Generating and writing .seq file...');
        }

        try {
            const response = await fetch('/api/write-seq', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    code: pypulseqCode
                })
            });

            const result = await response.json();

            if (!response.ok) throw new Error(result.error || 'Failed to write file');

            console.log(result.output);

            // Auto-confirm via UI message without blocking alert
            if (window.LLMInterface) {
                LLMInterface.addMessage('assistant', '✓ ' + result.message + '\nSaved as cardiac_sequence.seq');
            } else {
                console.log(result.message);
            }

        } catch (error) {
            console.error('Error writing seq file:', error);
            if (window.LLMInterface) {
                LLMInterface.addMessage('assistant', '❌ Error: ' + error.message);
            } else {
                console.error('Error: ' + error.message);
            }
        }
    },

    /**
     * Generate PyPulseq Python code
     */
    generatePyPulseqCode(config) {
        const code = `#!/usr/bin/env python3
"""
Cardiac MRI Pulse Sequence - Generated by Cardiac Parallel Imaging Generator
Configuration: ${JSON.stringify(config.parallelImaging.technique).toUpperCase()}
Acceleration Factor: R = ${config.parallelImaging.accelerationFactor}x
"""

import pypulseq as pp
import numpy as np

# Create sequence object
seq = pp.Sequence()

# System limits
system = pp.Opts(
    max_grad=32,  # mT/m
    grad_unit='mT/m',
    max_slew=130,  # T/m/s
    slew_unit='T/m/s',
    rf_ringdown_time=20e-6,
    rf_dead_time=100e-6,
    adc_dead_time=10e-6
)

# Imaging parameters
fov = ${config.fov || 400}e-3  # m
Nx, Ny = 256, 256
slice_thickness = 8e-3  # m
TE = 1.5e-3  # s
TR = 3e-3  # s

# Parallel imaging
acceleration_factor = ${config.parallelImaging.accelerationFactor}
num_acs_lines = ${config.parallelImaging.acsLines || 24}

# Calculate k-space sampling
delta_k = 1 / fov
k_width = Nx * delta_k
readout_time = 6.4e-3  # s

# Create 90-degree slice selection pulse
rf, gz, _ = pp.make_sinc_pulse(
    flip_angle=90 * np.pi / 180,
    duration=2e-3,
    slice_thickness=slice_thickness,
    apodization=0.5,
    time_bw_product=4,
    system=system,
    return_gz=True
)

# Create readout gradient
gx = pp.make_trapezoid(
    channel='x',
    flat_area=k_width,
    flat_time=readout_time,
    system=system
)

# Create ADC event
adc = pp.make_adc(
    num_samples=Nx,
    duration=readout_time,
    delay=gx.rise_time,
    system=system
)

# Phase encoding (undersampled for parallel imaging)
phase_areas = np.arange(Ny) - Ny / 2
phase_areas = phase_areas * delta_k

# Generate undersampled k-space pattern
if "${config.parallelImaging.technique}" == "grappa":
    # GRAPPA: uniform undersampling + ACS region
    sampled_lines = []
    for pe in range(Ny):
        if pe % int(acceleration_factor) == 0:
            sampled_lines.append(pe)
        elif abs(pe - Ny//2) < num_acs_lines // 2:
            sampled_lines.append(pe)  # ACS region
else:
    # SENSE: uniform undersampling
    sampled_lines = [pe for pe in range(Ny) if pe % int(acceleration_factor) == 0]

print(f"Acquiring {len(sampled_lines)} / {Ny} phase encode lines")
print(f"Effective R = {Ny / len(sampled_lines):.2f}x")

# Build sequence
for pe_idx in sampled_lines:
    # RF excitation
    seq.add_block(rf, gz)
    
    # Phase encoding
    gy = pp.make_trapezoid(
        channel='y',
        area=phase_areas[pe_idx],
        duration=2e-3,
        system=system
    )
    
    # Prephasing
    gx_pre = pp.make_trapezoid(
        channel='x',
        area=-gx.area / 2,
        duration=1e-3,
        system=system
    )
    
    seq.add_block(gx_pre, gy)
    
    # Readout
    seq.add_block(gx, adc)
    
    # Spoiling
    gx_spoil = pp.make_trapezoid(
        channel='x',
        area=2 * k_width,
        duration=1e-3,
        system=system
    )
    
    seq.add_block(gx_spoil)

# Check sequence timing
ok, error_report = seq.check_timing()
if ok:
    print("Sequence timing check passed!")
else:
    print("Timing errors detected:")
    print(error_report)

# Output statistics
print(f"\\nSequence Statistics:")
print(f"Total duration: {seq.duration()[0]:.2f} s")
print(f"Number of blocks: {len(seq.block_events)}")

# Write sequence
seq.write("cardiac_sequence.seq")
print("\\nSequence written to: cardiac_sequence.seq")
`;

        return code;
    },

    /**
     * Export vendor-specific format
     */
    exportVendor() {
        const config = this.gatherConfiguration();
        const vendorParams = this.generateVendorParams(config);

        Utils.downloadFile(vendorParams, 'cardiac_protocol.txt', 'text/plain');

        if (window.LLMInterface) {
            LLMInterface.addMessage('assistant', '✓ Vendor parameters exported!');
        }
    },

    /**
     * Generate vendor parameter file
     */
    generateVendorParams(config) {
        return `CARDIAC MRI PROTOCOL PARAMETERS
Generated: ${new Date().toISOString()}

========================================
PARALLEL IMAGING
========================================
Technique: ${config.parallelImaging.technique.toUpperCase()}
Acceleration Factor: R = ${config.parallelImaging.accelerationFactor}x
Coil Elements: ${config.parallelImaging.coilElements} channels
${config.parallelImaging.technique === 'grappa' ? 'ACS Lines: ' + config.parallelImaging.acsLines : ''}

========================================
CINE PARAMETERS
========================================
Sequence: Balanced SSFP (TrueFISP)
Temporal Resolution: ${config.cine.temporalRes} ms
Cardiac Phases: ${config.cine.cardiacPhases}
Heart Rate: ${config.cine.heartRate} bpm
RR Interval: ${Math.round(Utils.bpmToRR(config.cine.heartRate))} ms

========================================
IMAGE PARAMETERS
========================================
Field of View: ${config.fov || 400} mm
Matrix: 256 x 256
Slice Thickness: 8 mm
Slice Gap: 2 mm

========================================
NOTES
========================================
- Verify patient-specific parameters (HR, breath-hold capacity)
- Adjust TI for LGE based on TI scout
- Consider increasing acceleration if breath-hold limited
`;
    },

    /**
     * Export clinical protocol report
     */
    exportProtocol() {
        const config = this.gatherConfiguration();
        const report = this.generateProtocolReport(config);

        Utils.downloadFile(report, 'cardiac_protocol_report.html', 'text/html');

        if (window.LLMInterface) {
            LLMInterface.addMessage('assistant', '✓ Clinical protocol report generated!');
        }
    },

    /**
     * Generate HTML protocol report
     */
    generateProtocolReport(config) {
        return `<!DOCTYPE html>
<html>
<head>
    <title>Cardiac MRI Protocol Report</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; line-height: 1.6; }
        h1 { color: #2c5aa0; }
        h2 { color: #4a90e2; margin-top: 30px; }
        table { border-collapse: collapse; width: 100%; margin: 20px 0; }
        th, td { border: 1px solid #ddd; padding: 12px; text-align: left; }
        th { background-color: #4a90e2; color: white; }
        .highlight { background-color: #fff3cd; padding: 15px; border-left: 4px solid #ffc107; }
    </style>
</head>
<body>
    <h1>Cardiac MRI Protocol Report</h1>
    <p><strong>Generated:</strong> ${new Date().toLocaleString()}</p>
    
    <h2>Parallel Imaging Configuration</h2>
    <table>
        <tr><th>Parameter</th><th>Value</th></tr>
        <tr><td>Technique</td><td>${config.parallelImaging.technique.toUpperCase()}</td></tr>
        <tr><td>Acceleration Factor</td><td>R = ${config.parallelImaging.accelerationFactor}x</td></tr>
        <tr><td>Coil Array</td><td>${config.parallelImaging.coilElements} channels</td></tr>
        <tr><td>Estimated G-factor</td><td>${config.gFactor}</td></tr>
        <tr><td>SNR Penalty</td><td>${config.snrPenalty}</td></tr>
    </table>
    
    <h2>CINE Imaging</h2>
    <table>
        <tr><th>Parameter</th><th>Value</th></tr>
        <tr><td>Temporal Resolution</td><td>${config.cine.temporalRes} ms</td></tr>
        <tr><td>Cardiac Phases</td><td>${config.cine.cardiacPhases}</td></tr>
        <tr><td>Heart Rate</td><td>${config.cine.heartRate} bpm</td></tr>
    </table>
    
    <div class="highlight">
        <strong>Clinical Notes:</strong><br>
        • Protocol optimized for ${config.parallelImaging.accelerationFactor}x acceleration<br>
        • Estimated scan time reduction: ${Math.round((1 - 1 / config.parallelImaging.accelerationFactor) * 100)}%<br>
        • Verify patient breath-hold capacity before imaging
    </div>
</body>
</html>`;
    },

    /**
     * Gather all current configuration
     */
    gatherConfiguration() {
        const config = {
            parallelImaging: window.ParallelImaging ? ParallelImaging.getConfig() : {},
            cine: window.CardiacSequences ? CardiacSequences.getConfig('cine') : {},
            fov: 400
        };

        // Calculate metrics
        if (window.ParallelPhysics) {
            const gResult = ParallelPhysics.calculateGFactor(
                config.parallelImaging.accelerationFactor || 2,
                config.parallelImaging.coilElements || 18
            );
            const snrResult = ParallelPhysics.calculateSNRPenalty(
                gResult.gFactorMean,
                config.parallelImaging.accelerationFactor || 2
            );

            config.gFactor = gResult.gFactorMean.toFixed(2);
            config.snrPenalty = snrResult.snrPenaltyPercent.toFixed(0) + '%';
        }

        return config;
    }
};

// Export
window.ExportModule = ExportModule;
