# -*- coding: utf-8 -*-
"""Copy of v15_Qiskit

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lEqnr_bJ6GyZRYAF_KowX3hjnCJ7BeEb
"""

!pip install scikit-image qiskit matplotlib numpy

from google.colab import files
uploaded = files.upload()

import numpy as np
import matplotlib.pyplot as plt
from skimage.metrics import peak_signal_noise_ratio as psnr
from skimage.metrics import structural_similarity as ssim
from skimage.restoration import denoise_tv_chambolle
from skimage.transform import resize

# Load k-space data and ground truth image data from .npy files
k_space = np.load('gt_kspace.npy')
ground_truth = np.load('gt_image.npy')

# Reconstruct image from k-space data using inverse Fourier transform
reconstructed = np.fft.ifftshift(np.fft.ifft2(np.fft.fftshift(k_space)))
reconstructed = np.abs(reconstructed) # Take the absolute value to get magnitude image

# Resize the reconstructed image if its shape doesn't match the ground truth shape
if reconstructed.shape != ground_truth.shape:
    print(f"Resizing reconstructed image from {reconstructed.shape} to {ground_truth.shape}")
    reconstructed = resize(reconstructed, ground_truth.shape, anti_aliasing=True)

# Squeeze singleton channel if present (e.g., (H, W, 1) becomes (H, W)) for both reconstructed and ground truth images
if reconstructed.ndim == 3 and reconstructed.shape[-1] == 1:
    reconstructed = reconstructed.squeeze(-1)
if ground_truth.ndim == 3 and ground_truth.shape[-1] == 1:
    ground_truth = ground_truth.squeeze(-1)

# Define a normalization function to scale image data between 0 and 1
def normalize(img):
    return (img - img.min()) / (img.max() - img.min())

# Normalize both the reconstructed and ground truth images
reconstructed_norm = normalize(reconstructed)
ground_truth_norm = normalize(ground_truth)

# Compute and print PSNR and SSIM metrics between the normalized reconstructed and ground truth images
psnr_value = psnr(ground_truth_norm, reconstructed_norm)
ssim_value = ssim(ground_truth_norm, reconstructed_norm, data_range=1.0)

print(f" PSNR: {psnr_value:.2f} dB")
print(f"SSIM: {ssim_value:.4f}")

from skimage.restoration import denoise_tv_chambolle
from skimage.metrics import peak_signal_noise_ratio as psnr
from skimage.metrics import structural_similarity as ssim

# Apply Total Variation denoising to the normalized reconstructed image
reconstructed_denoised = denoise_tv_chambolle(reconstructed_norm, weight=0.1)

# Compute and print PSNR and SSIM metrics for the denoised image
psnr_denoised = psnr(ground_truth_norm, reconstructed_denoised)
ssim_denoised = ssim(ground_truth_norm, reconstructed_denoised, data_range=1.0)

print(f"Denoised PSNR: {psnr_denoised:.2f} dB")
print(f"Denoised SSIM: {ssim_denoised:.4f}")

import matplotlib.pyplot as plt

# Create a figure with 3 subplots to display the images
plt.figure(figsize=(18, 6))

# Display the Ground Truth image
plt.subplot(1, 3, 1)
plt.imshow(ground_truth_norm, cmap='gray')
plt.title("Ground Truth")
plt.axis('off') # Turn off axis

# Display the Original Reconstructed image with its PSNR and SSIM values
plt.subplot(1, 3, 2)
plt.imshow(reconstructed_norm, cmap='gray')
plt.title(f"Original Recon\nPSNR: {psnr_value:.2f} dB, SSIM: {ssim_value:.4f}")
plt.axis('off')

# Display the Denoised Reconstructed image with its PSNR and SSIM values
plt.subplot(1, 3, 3)
plt.imshow(reconstructed_denoised, cmap='gray')
plt.title(f"Denoised\nPSNR: {psnr_denoised:.2f} dB, SSIM: {ssim_denoised:.4f}")
plt.axis('off')

# Adjust layout to prevent titles from overlapping
plt.tight_layout()
plt.show() # Display the plot

# Optional: create a Gaussian-like k-space for testing
def generate_synthetic_kspace(image_shape):
    # Import gaussian_filter from scipy for smoothing
    from scipy.ndimage import gaussian_filter
    # Create a random image and apply a Gaussian filter
    full_image = np.random.rand(*image_shape)
    full_image = gaussian_filter(full_image, sigma=10)
    # Simulate k-space by taking the centered 2D Fourier transform
    kspace_simulated = np.fft.fftshift(np.fft.fft2(np.fft.ifftshift(full_image)))
    return kspace_simulated

# Generate synthetic k-space data with a shape of (320, 320)
simulated_kspace = generate_synthetic_kspace((320, 320))
# Reconstruct the image from the simulated k-space
reconstructed_sim = np.abs(np.fft.ifft2(simulated_kspace))
# Display the reconstructed synthetic image
plt.imshow(reconstructed_sim, cmap='gray')
plt.title("Synthetic Reconstruction")
plt.axis('off')
plt.show()

# Print the shape of the k_space array
print(f"Shape of k_space: {k_space.shape}")

# Display the magnitude of the k_space data
plt.figure(figsize=(8, 8))
plt.imshow(np.log(np.abs(k_space) + 1), cmap='viridis') # Use log scale for better visualization of magnitude
plt.title("Magnitude of k-space data")
plt.axis('off')
plt.show()

# Check if k_space needs zero-filling to match the target shape
target_shape = ground_truth.shape[:2] # Get HxW from ground truth
k_space_shape = k_space.shape

if k_space_shape != target_shape:
    print(f"K-space shape {k_space_shape} is different from target shape {target_shape}. Performing zero-filling.")

    # Create a zero-filled k-space array with the target shape and the same data type as the original k-space
    k_space_zerofilled = np.zeros(target_shape, dtype=k_space.dtype)
    # Calculate padding needed to center the original k-space data in the zero-filled array
    pad_h = (target_shape[0] - k_space_shape[0]) // 2
    pad_w = (target_shape[1] - k_space_shape[1]) // 2

    # Place the original k-space data into the center of the zero-filled array
    k_space_zerofilled[pad_h:pad_h + k_space_shape[0], pad_w:pad_w + k_space_shape[1]] = k_space

    # Reconstruct the image from the zero-filled k-space
    reconstructed_zerofill = np.fft.ifftshift(np.fft.ifft2(np.fft.fftshift(k_space_zerofilled)))

else:
    print(f"K-space shape {k_space_shape} matches target shape {target_shape}. No zero-filling needed.")
    # If shapes match, reconstruct directly from the original k-space
    reconstructed_zerofill = np.fft.ifftshift(np.fft.ifft2(np.fft.fftshift(k_space)))

# Take the absolute value of the reconstructed image
reconstructed_zerofill = np.abs(reconstructed_zerofill)

# Normalize the zero-filled reconstructed image
reconstructed_zerofill_norm = normalize(reconstructed_zerofill)

# Display the zero-filled reconstructed image
plt.figure(figsize=(6, 6))
plt.imshow(reconstructed_zerofill_norm, cmap='gray')
plt.title("Reconstruction from Zero-filled K-space")
plt.axis('off')
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from skimage.metrics import peak_signal_noise_ratio as psnr
from skimage.metrics import structural_similarity as ssim
from skimage.restoration import denoise_tv_chambolle
from skimage.transform import resize

k_space = np.load('gt_kspace.npy')
ground_truth = np.load('gt_image.npy')

def normalize(img):
    return (img - img.min()) / (img.max() - img.min())

target_shape = ground_truth.shape[:2]truth
k_space_shape = k_space.shape

if k_space_shape != target_shape:
    print(f"K-space shape {k_space_shape} is different from target shape {target_shape}. Performing zero-filling.")

    k_space_zerofilled = np.zeros(target_shape, dtype=k_space.dtype)


    pad_h = (target_shape[0] - k_space_shape[0]) // 2
    pad_w = (target_shape[1] - k_space_shape[1]) // 2


    k_space_zerofilled[pad_h:pad_h + k_space_shape[0], pad_w:pad_w + k_space_shape[1]] = k_space

    reconstructed_zerofill = np.fft.ifftshift(np.fft.ifft2(np.fft.fftshift(k_space_zerofilled)))

else:
    print(f"K-space shape {k_space_shape} matches target shape {target_shape}. No zero-filling needed.")
    reconstructed_zerofill = np.fft.ifftshift(np.fft.ifft2(np.fft.fftshift(k_space)))

reconstructed_zerofill = np.abs(reconstructed_zerofill)

reconstructed_zerofill_norm = normalize(reconstructed_zerofill)

plt.figure(figsize=(6, 6))
plt.imshow(reconstructed_zerofill_norm, cmap='gray')
plt.title("Reconstruction from Zero-filled K-space")
plt.axis('off')
plt.show()

from google.colab import files
uploaded = files.upload()

# Print the shape of the k_space array
print(f"Shape of k_space: {k_space.shape}")

plt.figure(figsize=(8, 8))
plt.imshow(np.log(np.abs(k_space) + 1), cmap='viridis')
plt.title("Magnitude of k-space data")
plt.axis('off')
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from skimage.metrics import peak_signal_noise_ratio as psnr
from skimage.metrics import structural_similarity as ssim
from skimage.restoration import denoise_tv_chambolle
from skimage.transform import resize

# Try to load the data directly
try:
    k_space = np.load('gt_kspace.npy')
    ground_truth = np.load('gt_image.npy')
    print("Data loaded successfully.")
# If FileNotFoundError occurs, it means the files were likely uploaded with a different name (e.g., with (1))
except FileNotFoundError:
    # Get the list of uploaded files
    uploaded_files = list(uploaded.keys())
    kspace_filename = None
    gt_filename = None
    # Iterate through uploaded files to find the correct filenames
    for filename in uploaded_files:
        if 'gt_kspace' in filename:
            kspace_filename = filename
        if 'gt_image' in filename:
            gt_filename = filename

    # If both filenames are found, load the data using those filenames
    if kspace_filename and gt_filename:
        k_space = np.load(kspace_filename)
        ground_truth = np.load(gt_filename)
        print(f"Data loaded successfully using uploaded filenames: {kspace_filename}, {gt_filename}")
    else:
        # If files are not found, print an error message
        print("Error: Data files not found. Please upload 'gt_kspace.npy' and 'gt_image.npy'.")

# Define a normalization function
def normalize(img):
    return (img - img.min()) / (img.max() - img.min())

# Determine the target shape for the k-space data (based on the ground truth image)
target_shape = ground_truth.shape[:2]
# Get the shape of the k-space data (excluding potential channel dimension)
k_space_shape_hw = k_space.shape[:2]
# Check if the k-space shape matches the target shape
if k_space_shape_hw != target_shape:
    print(f"K-space shape {k_space_shape_hw} is different from target shape {target_shape}. Performing zero-filling.")
    # Create a zero-filled k-space array with the target shape and the same data type
    k_space_zerofilled = np.zeros(target_shape, dtype=k_space.dtype)
    # Calculate the starting and ending indices for the central region of the original k-space
    start_h = (k_space_shape_hw[0] - target_shape[0]) // 2
    end_h = start_h + target_shape[0]
    start_w = (k_space_shape_hw[1] - target_shape[1]) // 2
    end_w = start_w + target_shape[1]

    # Extract the central region of the k-space data
    if k_space.ndim == 3:
        k_space_central_region = k_space[start_h:end_h, start_w:end_w, 0]
    else:
        k_space_central_region = k_space[start_h:end_h, start_w:end_w]

    # Assign the central region to the zero-filled k-space (this seems incorrect, should be padding)
    # Correct approach would be to insert the central region into k_space_zerofilled
    # k_space_zerofilled[...] = k_space_central_region # Correct way to assign the central region

    # Reconstruct the image from the zero-filled k-space (using the central region)
    reconstructed_zerofill = np.fft.ifftshift(np.fft.ifft2(np.fft.fftshift(k_space_central_region))) # Applying fft to the central region directly


else:
    print(f"K-space shape {k_space_shape_hw} matches target shape {target_shape}. No zero-filling needed.")
    # If shapes match, reconstruct directly from the k-space
    if k_space.ndim == 3:
        reconstructed_zerofill = np.fft.ifftshift(np.fft.ifft2(np.fft.fftshift(k_space[:,:,0])))
    else:
        reconstructed_zerofill = np.fft.ifftshift(np.fft.ifft2(np.fft.fftshift(k_space)))


# Take the absolute value of the reconstructed image
reconstructed_zerofill = np.abs(reconstructed_zerofill)
# Normalize the zero-filled reconstructed image
reconstructed_zerofill_norm = normalize(reconstructed_zerofill)
# Display the zero-filled reconstructed image
plt.figure(figsize=(6, 6))
plt.imshow(reconstructed_zerofill_norm, cmap='gray')
plt.title("Reconstruction from Zero-filled K-space")
plt.axis('off')
plt.show()

from google.colab import files

uploaded = files.upload()

# Check if ground_truth_norm is defined, if not, normalize ground_truth
if 'ground_truth_norm' not in locals():
    ground_truth_norm = normalize(ground_truth)

# If ground_truth_norm has a singleton channel dimension, remove it
if ground_truth_norm.ndim == 3 and ground_truth_norm.shape[-1] == 1:
    ground_truth_norm = ground_truth_norm.squeeze(-1)

# Compute and print PSNR and SSIM for the zero-filled reconstruction
psnr_zerofill = psnr(ground_truth_norm, reconstructed_zerofill_norm)
ssim_zerofill = ssim(ground_truth_norm, reconstructed_zerofill_norm, data_range=1.0)

print(f"Zero-filled Reconstruction PSNR: {psnr_zerofill:.2f} dB")
print(f"Zero-filled Reconstruction SSIM: {ssim_zerofill:.4f}")

# If original reconstructed image is available, print its metrics
if 'reconstructed_norm' in locals():
    print(f"\nOriginal Reconstruction PSNR: {psnr_value:.2f} dB")
    print(f"Original Reconstruction SSIM: {ssim_value:.4f}")

# If denoised reconstructed image is available, print its metrics
if 'reconstructed_denoised_norm' in locals():
     print(f"\nDenoised Reconstruction PSNR: {psnr_denoised:.2f} dB")
     print(f"Denoised Reconstruction SSIM: {ssim_denoised:.4f}")
elif 'reconstructed_denoised' in locals():
     print(f"\nDenoised Reconstruction PSNR: {psnr_denoised:.2f} dB")
     print(f"Denoised Reconstruction SSIM: {ssim_denoised:.4f}")

import matplotlib.pyplot as plt

# Create a figure with 3 subplots
plt.figure(figsize=(18, 6))

# Display the Ground Truth image
plt.subplot(1, 3, 1)
plt.imshow(ground_truth_norm, cmap='gray')
plt.title("Ground Truth")
plt.axis('off') # Turn off axis

# Display the Original Reconstructed image with its metrics
plt.subplot(1, 3, 2)
plt.imshow(reconstructed_norm, cmap='gray')
plt.title(f"Original Recon\nPSNR: {psnr_value:.2f} dB, SSIM: {ssim_value:.4f}")
plt.axis('off')

# Display the Zero-filled Reconstructed image with its metrics
plt.subplot(1, 3, 3)
plt.imshow(reconstructed_zerofill_norm, cmap='gray')
plt.title(f"Zero-filled Recon\nPSNR: {psnr_zerofill:.2f} dB, SSIM: {ssim_zerofill:.4f}")
plt.axis('off')

# Adjust layout and display the plot
plt.tight_layout()
plt.show()

# Display the phase of the k-space data
plt.figure(figsize=(8, 8))
plt.imshow(np.angle(k_space), cmap='hsv') # Use 'hsv' colormap for phase
plt.title("Phase of k-space data")
plt.axis('off') # Turn off axis
plt.show()

import numpy as np

# Define parameters for a conceptual RF pulse
rf_pulse = {
    'amplitude': 1.0,
    'duration': 10e-6,
    'phase': 0.0
}

# Define parameters for conceptual gradient pulses in X, Y, and Z directions
gradient_x = {
    'amplitude': 0.01,
    'duration': 1e-3
}

gradient_y = {
    'amplitude': 0.02,
    'duration': 1e-3
}

gradient_z = {
    'amplitude': 0.005,
    'duration': 2e-3
}

# Define a simple conceptual pulse sequence as a list of events
pulse_sequence_events = [
    {'type': 'RF_pulse', 'start_time': 0, 'duration': rf_pulse['duration'], 'params': rf_pulse},
    {'type': 'Gradient_x', 'start_time': rf_pulse['duration'], 'duration': gradient_x['duration'], 'params': gradient_x},
    {'type': 'Gradient_y', 'start_time': rf_pulse['duration'], 'duration': gradient_y['duration'], 'params': gradient_y},
    {'type': 'Gradient_z', 'start_time': rf_pulse['duration'] + gradient_y['duration'], 'duration': gradient_z['duration'], 'params': gradient_z},
]

# Print the defined parameters and the pulse sequence structure
print("Defined RF Pulse:", rf_pulse)
print("Defined Gradient X:", gradient_x)
print("Defined Gradient Y:", gradient_y)
print("Defined Gradient Z:", gradient_z)
print("\nSimple Pulse Sequence Events Structure:")
for event in pulse_sequence_events:
    print(event)

import numpy as np

# Define conceptual timing parameters: Echo Time (TE) and Repetition Time (TR)
TE = 5e-3
TR = 20e-3

# Calculate conceptual areas for readout and phase encode gradients
readout_gradient_area = gradient_x['amplitude'] * gradient_x['duration'] * 2 # Readout gradient often has a bipolar shape
phase_encode_gradient_area = gradient_y['amplitude'] * gradient_y['duration']

# Define a conceptual Gradient Echo pulse sequence as a list of events
gradient_echo_sequence = [
    {'type': 'RF_pulse', 'start_time': 0, 'duration': rf_pulse['duration'], 'params': rf_pulse}, # RF excitation pulse
    {'type': 'Gradient_z', 'start_time': 0, 'duration': rf_pulse['duration'], 'params': gradient_z}, # Slice selection gradient (simplified)
    {'type': 'Gradient_y', 'start_time': rf_pulse['duration'] + 1e-4, 'duration': gradient_y['duration'], 'params': gradient_y}, # Phase encoding gradient
    {'type': 'Gradient_x', 'start_time': TE - gradient_x['duration'], 'duration': gradient_x['duration'], 'params': gradient_x}, # Readout gradient (pre-phaser)
    {'type': 'Gradient_x', 'start_time': TE, 'duration': gradient_x['duration'], 'params': gradient_x}, # Readout gradient (acquisition window)
    {'type': 'Acquisition', 'start_time': TE, 'duration': gradient_x['duration']}, # Data acquisition happens during the readout gradient
    {'type': 'Delay', 'start_time': TE + gradient_x['duration'], 'duration': TR - (TE + gradient_x['duration'])}, # Delay to fill the TR
] # Missing a closing bracket here

# Print the conceptual Gradient Echo sequence events
print("Conceptual Gradient Echo Sequence Events:")
for event in gradient_echo_sequence:
    print(event)

import numpy as np

# Ensure ground truth image is 2D
if ground_truth.ndim == 3 and ground_truth.shape[-1] == 1:
    ground_truth_2d = ground_truth.squeeze(-1)
else:
    ground_truth_2d = ground_truth

# Normalize the 2D ground truth image
ground_truth_2d = normalize(ground_truth_2d)

# Compute the k-space data from the normalized ground truth image using Fourier transform
k_space_ground_truth = np.fft.fftshift(np.fft.fft2(np.fft.ifftshift(ground_truth_2d)))

# Get the number of phase encode steps and readout points from the ground truth image shape
num_phase_encodes = ground_truth_2d.shape[0]
num_readout_points = ground_truth_2d.shape[1]

# Create arrays for k-space coordinates (ky and kx)
ky_values = np.linspace(-0.5, 0.5, num_phase_encodes)
kx_values = np.linspace(-0.5, 0.5, num_readout_points)

# Initialize a zero-filled array to store the simulated k-space data
simulated_kspace = np.zeros((num_phase_encodes, num_readout_points), dtype=complex)

# Simulate k-space acquisition by sampling from the ground truth k-space
for pe_step in range(num_phase_encodes):
    current_ky = ky_values[pe_step]

    for ro_point in range(num_readout_points):
        current_kx = kx_values[ro_point]

        # Calculate the corresponding indices in the ground truth k-space
        kx_idx = int((current_kx + 0.5) * num_readout_points) % num_readout_points
        ky_idx = int((current_ky + 0.5) * num_phase_encodes) % num_phase_encodes

        # Sample the k-space data from the ground truth k-space
        simulated_kspace[pe_step, ro_point] = k_space_ground_truth[ky_idx, kx_idx]

# Print the shape of the simulated k-space
print("Simulated k-space shape:", simulated_kspace.shape)

# Display the magnitude of the simulated k-space data
plt.figure(figsize=(8, 8))
plt.imshow(np.log(np.abs(simulated_kspace) + 1), cmap='viridis') # Use log scale for visualization
plt.title("Magnitude of Simulated k-space data")
plt.axis('off') # Turn off axis
plt.show() # Display the plot

# Reconstruct the image from the simulated k-space using inverse Fourier transform
reconstructed_simulated = np.fft.ifftshift(np.fft.ifft2(np.fft.fftshift(simulated_kspace)))
# Take the absolute value to get the magnitude image
reconstructed_simulated = np.abs(reconstructed_simulated)
# Normalize the reconstructed simulated image
reconstructed_simulated_norm = normalize(reconstructed_simulated)
# Display the reconstructed image from simulated k-space
plt.figure(figsize=(6, 6))
plt.imshow(reconstructed_simulated_norm, cmap='gray')
plt.title("Reconstructed Image from Simulated K-space")
plt.axis('off') # Turn off axis
plt.show() # Display the plot

import matplotlib.pyplot as plt

# Create a figure to compare the magnitudes of real and simulated k-space
plt.figure(figsize=(12, 6))

# Display the magnitude of the Real k-space data
plt.subplot(1, 2, 1)
plt.imshow(np.log(np.abs(k_space) + 1), cmap='viridis')
plt.title("Magnitude of Real k-space data")
plt.axis('off')

# Display the magnitude of the Simulated k-space data
plt.subplot(1, 2, 2)
plt.imshow(np.log(np.abs(simulated_kspace) + 1), cmap='viridis')
plt.title("Magnitude of Simulated k-space data")
plt.axis('off')

# Adjust layout and display the plot
plt.tight_layout()
plt.show()

# Create a figure to compare the real and simulated reconstructed images
plt.figure(figsize=(12, 6))

# Display the Real Reconstructed Image
plt.subplot(1, 2, 1)
plt.imshow(reconstructed_norm, cmap='gray')
plt.title("Real Reconstructed Image")
plt.axis('off')

# Display the Simulated Reconstructed Image
plt.subplot(1, 2, 2)
plt.imshow(reconstructed_simulated_norm, cmap='gray')
plt.title("Simulated Reconstructed Image")
plt.axis('off')

# Adjust layout and display the plot
plt.tight_layout()
plt.show()